---
layout: post
title: "Ustage Day 2"
categories: boostcamp
tags: main
comments: true
---
경사하강법과 기초 딥러닝 그리고 확률론에 대한 설명을 진행한다.

**부스트 캠프 2일차 학습 요약**
- **강의** : 경사하강법 - 순한맛, 경사하강법 - 매운맛, 딥러닝 학습방법 이해하기, 확률론 맛보기
- **피어 세션**

## 목차
- [1. 경사하강법 - 순한맛](#1-경사하강법---순한맛)
- [2. 경사하강법 - 매운맛](#2-경사하강법---매운맛)
- [3. 딥러닝 학습방법 이해하기](#3-딥러닝-학습방법-이해하기)
- [4. 확률론 맛보기](#4-확률론-맛보기)
- [5. 과제 수행 결과물 by Colab](#5-과제-수행-결과물-by-colab)
- [6. 피어 세션](#6-피어-세션)
- [7. 2일차 후기](#7-2일차-후기)
- [8. 해야할 일](#8-해야할-일)

## 1. 경사하강법 - 순한맛
### 1-1. 미분이 뭔가요?
- 변수의 움직임에 따른 함수값의 변화를 측정하기 위한 도구로 최적화에서 제일 많이 사용하는 기법이다.
- 미분식은 다음과 같으며 변화율의 극한으로 정의한다.
![미분](https://user-images.githubusercontent.com/53552847/128277342-81501c21-84a1-43ad-8505-0802a58d951f.png)
- Python에서 미분은 `import sympy`로부터 `sympy.diff`를 활용하여 미분 계산을 할 수 있다.

### 1-2. 미분은 어디에 쓸까?
- 함수 $$f$$의 주어진 점 $$(x, f(x))$$ 에서의 접선의 기울기를 구한다.
- 연속일 경우 미분할 수 있다.
- **접선의 기울기를 바탕으로 어느 방향으로 점을 움직여야 함수값이 증가 혹은 감소하는지 알 수 있다. > 더하면 함수값 증가, 뺴면 감소**
- 목적함수를 최소화하기 위하여 경사하강법을 사용하는데 이때 미분을 활용한다.
- 경사 하강 혹은 상승을 사용할 때 극값에 도달하면 미분값이 0에 가까워져 최적화가 종료된다.

### 1-3. 경사하강법 알고리즘
- 컴퓨터로 계산을 진행할 경우 미분값이 정확히 0이 나오는 것이 불가능하므로 특정 종료조건을 입력해주어야 한다. 다음을 확인하자.
![경사하강법 알고리즘](https://user-images.githubusercontent.com/53552847/128277685-94a899e6-5e06-4b96-b821-6df4b908b167.png)
- 위의 그림에서 lr은 학습률로서 미분을 활용해 업데이트 하는 속도를 조절한다.
- 학습률의 경우 조심해서 제어를 해야한다. 학습률로 인해 경사하강법이 수렴을 안 할수도 있기 때문이다.
- 다음은 $$f(x) = x^2 + 2x + 3$$의 최소점을 경사하강법을 이용해 찾는 코드이다.
![경사하강법 변수 한개 코드](https://user-images.githubusercontent.com/53552847/128277891-19a87ffe-f0cc-4407-ae4f-d1e190dcddc8.png)

### 1-4. 경사하강법 알고리즘 - 변수가 벡터일 경우
- 벡터가 입력인 다변수 함수의 경우 편미분을 이용한다.
![경사하강법 벡터 미분](https://user-images.githubusercontent.com/53552847/128277972-776d7b10-f2e7-4b64-bab3-d8a553f0e328.PNG)
- 위에서 $$e_i$$는 $$i_{th}$$ 원소만 1이고 나머지는 0인 단위벡터를 의미한다.
- Gradient Vector = 각 변수별로 편미분한 값을 원소로 가지는 벡터
- Gradient Vector는 다음과 같으며, 경사하강법 혹은 경사상승법에 활용할 수 있다.
![그래디언트 벡터](https://user-images.githubusercontent.com/53552847/128278137-7b96818e-5022-4184-b870-d1c13da0077f.PNG)
- Gradient Vector는 각 점에서 가장 빨리 증가 혹은 감소하는 방향으로 흐르게 된다. 즉, 이를 활용하면 임의의 점에서 최소점으로 가장 빨리 감소하게 만들 수 있는 것이다.
- 변수가 벡터일 경우에는 종료조건을 Norm을 이용해서 입력해준다. 더불어, $$x^2 + 2y^2$$의 최소점을 경사하강법을 이용해 찾는 코드를 확인해보자.
![경사하강법 벡터 알고리즘](https://user-images.githubusercontent.com/53552847/128278563-f0a1d0bd-de43-4e3a-a9d2-1b386ae854bc.PNG)
![경사하강법 벡터 코드](https://user-images.githubusercontent.com/53552847/128278578-75770031-ce47-45e8-abad-4dbdab6e2480.PNG)

## 2. 경사하강법 - 매운맛
### 2-1. 경사하강법을 이용하여 선형모델을 찾는 방법
- 기존에 선형모델의 경우 Moore-Penrose 역행렬을 이용하여 찾을 수 있다.
- 선형모델이 아닐 경우에는 경사하강법을 이용해 모델을 찾을 수 있다.
- 선형회귀에 대하여 경사하강법으로 모델을 찾는 과정을 수행해보도록 한다.
    - 선형회귀의 목적식은 $$L_2$$ Norm이다. >> 실제값에서 부터 예측 직선 사이의 거리의 합을 최소로 하기 때문이다.
    - 목적식을 미지수 $$\beta$$로 미분하여 그 값을 계속 빼주는 과정을 통해 최소점을 구할 수 있다.
    - Gradient Vector는 다음과 같다.
    ![선형회귀 경사하강법 식](https://user-images.githubusercontent.com/53552847/128279095-37d5fbc3-0f28-4b56-bbad-4261cfc5ec3b.PNG)
    ![선형회귀 경사하강법 결과식](https://user-images.githubusercontent.com/53552847/128279102-77c8a25c-d19d-4b64-a7a2-d8c0c1f45021.PNG)

### 2-2. 목적식을 최소화하는 $$\beta$$를 구하는 경사하강법 알고리즘
- $$\beta$$를 업데이트 하는 방법은 다음과 같다.
![경사하강법 알고리즘 베타식](https://user-images.githubusercontent.com/53552847/128279254-903b6a8f-3268-484b-bd33-cc73eaf07d06.PNG)
- 위의 그림에서 $$\lambda$$의 경우 학습률(속도 조절)을 의미한다.
- 선형회귀의 경우 목적식이 $$L_2$$ Norm이지만 이를 최소화하는 것과 제곱식을 최소화 하는 $$\beta$$가 동일하므로 목적식의 제곱을 최소화하는 식을 활용할 수 있다.
![선형회귀 경사하강법 제곱텀](https://user-images.githubusercontent.com/53552847/128279452-026ef66b-aa09-445a-bcdb-b284c74eb99c.PNG)
- 경사하강법을 이용해 선형회귀의 모델을 찾는 코드를 확인해보자.
![선형회귀 경사하강법 코드](https://user-images.githubusercontent.com/53552847/128279580-af5d0877-2b18-4997-9ae2-823de1a71c20.PNG)
![선형회귀 경사하강법 진짜 코드](https://user-images.githubusercontent.com/53552847/128279588-e4768474-206b-483a-8211-5bb930f9a385.PNG)

### 2-3. 경사하강법은 만능일까?
- 경사하강법을 이용한 최적화를 이용할 때는 학습률(lr), 학습횟수(T)를 적절하게 선택해야 한다.
- 이론적으로 경사하강법은 미분가능하고 볼록한 함수에 대해서만 적절한 학습률과 학습횟수를 선택했을 때 수렴이 보장된다.
- 비선형회귀 문제의 경우 목적식이 Non-Convex인 경우가 대다수이므로 수렴이 보장되지 않는다.(특히, 딥러닝) 
- 위의 문제들을 해결하기위해 SGD가 등장하였다.

### 2-4. 확률적 경사하강법(SGD)
- 모든 데이터를 사용해 업데이트를 하는 대신 데이터를 한 개 혹은 일부를 활용하여 업데이트 한다.
- Non-Convex한 목적식을 SGD를 활용해 최적화할 수 있다.
- 실증적으로 GD보다 SGD가 더 낫다는 것이 검증되었다.
- 흔히 MSGD(Mini-Batch Stochastic Gradient Descent)를 SGD로 부른다.
- SGD의 경우 데이터의 일부만 가지고 학습하기 때문에 연산자원을 좀 더 효율적으로 활용할 수 있다.(총 n개 중 b개를 활용한다면 연산량은 O($$d^2$$n)에서 O($$d^2$$b)가 되어 연산효율이 더 좋아진다.) 

### 2-5. SGD의 원리
- Gradient의 값은 다르지만 GD와 방향은 유사할 것으로 기대한다.
- 매 Epoch마다 다른 Mini-Batch를 사용하게 됨으로써 목적식이 매번 바뀌게 된다.
- 목적식이 달라지기 때문에 현재 기울기가 0이라 할지라도 다음 Mini-Batch에서의 기울기는 0이 아닐 수 있다. 즉, Local Optima에서 벗어날 수 있다.
- SGD에서는 학습률(lr), 학습횟수(T) 뿐만 아니라 Mini-Batch_size 역시 신중하게 고려해야할 대상이다.

## 3. 딥러닝 학습방법 이해하기
- 비선형 모델인 신경망에 대하여 학습한다.
- d개의 변수로 p개의 선형모델을 만들어 p개의 잠재변수를 설명하는 모델

### 3-1. Softmax 함수
- 모델의 출력을 확률로 해석할 수 있게 변환해주는 연산
- 분류 문제를 풀 때 선형모델과 Softmax 함수를 결합하여 예측할 수 있다.
- Softmax 연산은 지수함수를 활용한 연산이며 다음 코드를 보고 이해해보자.
![softmax](https://user-images.githubusercontent.com/53552847/128290264-1ed9add6-bed0-4e97-9b96-0f68e286b712.png)
- 위의 코드에서 `vec - np.max(vec)`을 하는 이유는 지수함수 연산인 Softmax의 Overflow를 방지하기 위해서이다.
- 벡터 역시 Softmax 함수를 통해 확률벡터로 변환가능하다.
- 추론할 경우에는 Softmax 대신 결과(1 혹은 0)가 나오게 하는 원-핫 벡터를 사용한다. 원-핫벡터는 '가장 높은 확률을 가지는 것은 1 나머지는 0'과 같은 방식으로 치환해주는 방식이다. 원-핫벡터의 코드는 다음과 같다.
![one-hot](https://user-images.githubusercontent.com/53552847/128290465-4a5ab231-7ecb-4e88-8282-ac1896ee206d.PNG)

### 3-2. 활성함수 그리고 신경망
- 선형모델과 활성함수를 합성한 함수
- 활성함수 : 비선형함수를 의미하며 잠재벡터 각각의 노드에 개별적으로 적용함으로서 새로운 잠재벡터를 만들어주는 함수이다.
- 활성함수는 하나의 실수값을 입력으로 받는다.
- 활성함수를 통해 선형모델을 비선형모델로 전환시킬 수 있다.
- 신경망이 여러층 합성된 함수를 Multi-Layer Perceptron(MLP)라고 한다.
- 활성함수가 없는 신경망은 선형모형과 차이가 없다.
- 활성함수의 종류에는 sigmoid / tanh / ReLU 등이 있는데 이 중에서 ReLU가 전형적인 비선형함수이면서 활성함수로서의 좋은 성질들을 가지고 있어서 많이 활용된다.

### 3-3. Why Multi-Layer?
- 이론적으로 2층 신경망도 임의의 연속함수를 근사(Universal Approximation Theorem)시킬 수 있지만 층이 얇으면 얇을수록 필요한 뉴런의 수가 기하급수적으로 늘어나 매우 Wide 한 신경망이 되어야 한다.
- 층이 깊을수록 목적함수를 근사하는데 필요한 뉴런의 수가 빨리 줄어들어 더 효율적인 학습이 가능하다.
- 하지만, 층이 깊다고 해서 최적화가 더 쉬운 것은 아니다.
- 정리하자면, 층을 여러개 쌓는 이유는 적은 파라미터를 가지고 복잡한 패턴을 찾을 수 있기 때문이다.

### 3-4. BackPropagation
- 딥러닝은 역전파 알고리즘을 활용하여 각 층에서 사용된 파라미터를 학습한다.(W, b)
- 손실함수 L에 대하여 $$\frac{\partial{L}}{\partial{W_i}}$$ 정보를 계산할 때 역전파 알고리즘을 사용한다.
- 선형모델의 경우 한 층에서만 경사하강법을 진행하므로 Gradient Vector를 동시에 구할 수 있지만, 딥러닝의 경우 순차적으로, 각 층별로 쌓아서 계산하기 때문에 Gradient Vector를 한 번에 구할 수 없고 Back Propagation을 통해 순차적으로 구하게 된다.
- 각 Parameter의 Gradient Vector는 위에서부터 역순으로 구한다.
- Chain Rule에 의해서 Gradient Vector를 구할 수 있다. 다음 그림을 보고 이해를 돕고자 한다.
![역전파](https://user-images.githubusercontent.com/53552847/128291646-7912bfd3-62b9-4527-b818-eeb256487f1d.PNG)
- Chain Rule 기반 Auto-Differentiation을 사용한다.
- Forward Propagation보다 메모리를 많이 사용한다 -> 각 노드의 텐서값을 메모리에 저장시켜놔야지만 미분이 계산가능하기 때문이다.
- 순방향, 역방향 전파 알고리즘을 그림으로 표현하면 다음과 같다. 확인 후 넘어가도록 하자.
![순방향_역방향](https://user-images.githubusercontent.com/53552847/128291756-2baef1e1-3347-4a44-89d2-fe0e5012e38f.PNG)

## 4. 확률론 맛보기
### 4-1. 딥러닝에 왜 확률론이 필요한가?
- 딥러닝은 확률론 기반의 기계학습 이론에 바탕을 두고 있다.
- 기계학습에서 사용되는 Loss Function의 작동 원리는 데이터 공간을 통계적으로 해석함으로서 유도하게 된다.
- 예측이 틀릴 위험을 최소화하도록 데이터를 학습한다는 것이 통계적 기계학습의 기본 원리
- 회귀분석에서 Loss Function으로 사용되는 $L_2$ Norm은 예측 오차의 분산을 가장 최소화하는 방향으로 학습을 유도한다.
- 분류문제에서 사용되는 Cross Entropy는 모델 예측의 불확실성을 최소화하는 방향으로 학습을 유도한다.
- 분산 및 불확실성을 최소화하기 위해서는 이를 측정하는 방법을 알아야한다.
- 두 대상을 측정하는 방법을 통계학에서 제공하기 때문에 기계학습을 이해하기 위해서는 확률론의 기본 개념을 알아야한다.

### 4-2. 확률변수의 종류
- 확률변수는 확률분포 D에 따라 이산형과 연속형으로 구분된다.
- 데이터 공간 $$X$$ x $$Y$$ 에 의해 결정되는 것이 아닌 확률분포 D에 의해서 이산인지 연속인지 결정된다.
- 연속인지 이산인지에 따라서 확률값의 확률분포를 구하는 모델링 방식의 차이가 있다.
- 대부분 연속, 이산으로 나뉘지만 꼭 연속, 이산으로 나뉘는 것은 아니다.
- 결합분포에서 확률분포의 이산은, 연속이 다르다 할지라도 이산의 연속근사와 같은 방법이 있으므로 결합분포의 이산, 연속은 주어진 데이터의 모양을 보고 적절하게 선택하도록 한다.
- 다음의 그림처럼, 결합분포의 각 변수에 대한 합 또는 적분을 통해 각 변수의 주변확를 분포 $$P(x)$$, $$P(y)$$를 구할 수 있다.
![주변확률변수](https://user-images.githubusercontent.com/53552847/128298207-cb18d761-b471-4afa-b248-3b3bcbcc7440.PNG)
- 조건부확률분포 $$P(x|y)$$ 는 데이터 공간에서 입력 x와 출력 y 사이의 관계를 모델링한다. 특정 클래스가 주어진 조건에서 데이터의 확률분포를 보여준다.

### 4-3. 이산형확률변수와 연속확률변수
- 이산형 확률변수의 경우 확률변수가 가질 수 있는 경우의 수를 모두 고려하여 확률을 더해서 모델링한다.
- 이산형 확률변수는 다음과 같다.
![이산형 확률변수](https://user-images.githubusercontent.com/53552847/128298618-2ab99e11-bb93-4cb5-a5e0-d740bd8d08c1.PNG)
- 연속형 확률변수의 경우 데이터 공간에 정의된 확률변수의 밀도 위에서의 적분을 통해 모델링한다.
- 연속 확률변수에서 주의해야할 것은 밀도는 누적확률분포의 변화율을 모델링하는 것이다. 확률로 이해하지 않도록 주의하자.
- 연속형 확률변수는 다음과 같다.
![연속형 확률변수](https://user-images.githubusercontent.com/53552847/128298637-1693ec13-4ed8-4a32-95e5-87fa0c982422.PNG)

### 4-4. 조건부확률과 기계학습
- $$P(y|x)$$ 는 입력변수 x에 대해 정답이 y일 확률을 의미한다. 연속확률분포일 경우에 확률이 아닌 밀도로 해석한다는 것을 주의하자.
- 로지스틱 회귀에서 사용했던 선형모델과 Softmax 함수의 결합은 데이터에서 추출된 패턴을 기반으로 확률을 해석하는데 사용한다. (데이터 x로부터 추출된 특징패턴 $$\phi$$(x)와 가중치행렬을 통해 조건부확률 P(y|$$\phi(x)$$)를 계산한다.
- 회귀문제의 경우 조건부 기대값 $$E[y|x]$$를 추정하는데 이는 회귀문제의 경우 연속형 확률변수이기 때문이다. 더불어, 회귀의 목적함수인 $L_2$ Norm의 기댓값이 조건부 기대값을 최소화하는 것과 동일하므로 사용할 수 있다.
- 조건부 기대값의 식은 다음과 같다.
![조건부기댓값](https://user-images.githubusercontent.com/53552847/128300061-e725f613-65e7-4fe9-b0cf-a8b589167ebd.PNG)
- 통계적 모형에서 원하고자 하는 목적에 따라 사용되는 어떠한 통계 estimator가 달라질 수 있다.(회귀 - 조건부 기댓값, 로지스틱회귀 - 조건부 확률 계산 등등)
- 딥러닝에서는 MLP를 통해 데이터의 특징패턴 $$\phi$$를 얻어낸 후에 조건부 확률을 계산하거나 조건부 기대값을 추정하는 식으로 학습한다.
- 특징패턴을 학습하기 위해 어떤 손실함수를 사용할지는 기계학습 문제와 모델에 의해 결정된다.

### 4-5. 기대값이 뭔가요?
- 확률분포가 주어지면 데이터를 분석하는 데 사용 가능한 여러 종류의 통계적 범함수를 계산할 수 있다.
- 기대값은 데이터를 대표하는 통계량이면서 동시에 확률분포를 통해 다른 통계적 범함수를 계산하는데 사용된다.
![기대값](https://user-images.githubusercontent.com/53552847/128300392-ea2e4f70-7b50-4c1c-b348-9cbf9c467bc9.PNG)
- 기대값 역시 연속일 경우에는 적분을, 이산일 경우에는 합을 통해 얻을 수 있다.
- 기대값을 통해 분산, 첨도, 공분산 등 여러 통계량을 계산할 수 있다.

### 4-6. 몬테카를로 샘플링
- 기계학습의 많은 문제들은 확률분포를 명시적으로 모를 때가 대부분이다.
- 이 때, 데이터를 이용하여 기대값을 계산해야하는데 몬테카를로 샘플링 방법을 사용함으로서 구할 수 있다.
- 몬테카를로 샘플링 방법은 다음과 같다.
![몬테카를로 샘플링](https://user-images.githubusercontent.com/53552847/128300771-3c614b52-99e7-4567-8979-3115f773ea45.PNG)
- 위 식에서 $x_i$는 샘플링한 데이터를 의미한다.
- 몬테카를로 샘플링의 경우 이산이든, 연속이든 관계없이 성립한다. 단, 독립적인 샘플링이 이루어져야 몬테카를로 샘플링을 이용할 수 있다.
- 몬테카를로 샘플링은 독립추출만 보장된다면 대수의 법칙에 의해 수렴성을 보장한다.
- 몬테카를로 샘플링 코드는 다음과 같다.
![몬테카를로 샘플링 코드](https://user-images.githubusercontent.com/53552847/128300953-b9a70f14-0217-4791-adf2-53eb2e59b74d.PNG)
- 샘플의 수가 작게되면 오차범위가 커질 수 있다. 그러므로 적절한 샘플링 개수를 선택하는 것 역시 중요하다.

## 5. 과제 수행 결과물 by Colab
### 5-1. 필수 과제 Baseball
[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://drive.google.com/file/d/1qbduHfyqXZ21ipyN-XAmcHpzz3BoPf45/view?usp=sharing)

### 5-2. 필수 과제 Morsecode
[![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://drive.google.com/file/d/1_bzHeiSG2rqXFf1nttStfXQY90TG0unE/view?usp=sharing)

## 6. 피어 세션
### 6-1. 이전 질문 리뷰
- Moore-Penrose Inverse Matrix : 해당 공식의 이해 방법 및 유도 과정을 토의함.

### 6-2. 금일 질문 목록
- $$L_2$$ Norm을 사용한 경사하강법의 미분에 대해 질문함.
- 경사하강법의 목적식에 관해 환기함.
- 모든 데이터에 대해 한 번에 최적화하는 방식에 비해 미니배치 훈련 방식의 연산량 감소 이유에 대해 질문함.

### 6-3. 그라운드 룰 수정 건의
- 기존 그라운드 룰 중 '코드 리뷰와 강의 내용 리뷰'에 관해, 앞으로의 학습 난이도 증가에 따른 시간 소요가 늘어날 것으로 예상됨
- 따라서 피어세션 진행 형식을 미리 정하면 계획적으로 시간을 활용할 수 있을 것
- 각 팀원이 주 단위로 AI 관련 기술, 이론, 논문 등을 발표하는 룰이 제안됨
- 팀원 발표 경청
- 개인 노트에 과제 코드리뷰 포함

### 6-4. 코드 공유를 위한 Git 사용
- 과제 코드 리뷰 및 첨삭을 위한 git 저장소 구축
- 각 팀원 이름으로 구성된 Branch에서 작업

## 7. 2일차 후기
금일 처음으로 간단한 프로그래밍을 하는 과제 코드가 주어졌다.  
제대로된 프로그래밍을 해본 경험이 없어서 그런지 main함수를 작성하는 것만으로도 생각보다 오랜 시간이 소요됬고 어려움을 겪었다. 그래도 끝끝내 해결했다는 것에 의미를 두었고 조금은 만족할 수 있었다.

프로그래밍 과제 때문인지 강의를 수강하고 정리를 하는데 시간이 생각보다 지체됬던 것 같다.  
앞으로는 과제를 진행하는 시간 분배도 잘 해야할 것으로 판단된다.

피어세션을 통해 궁금했던 내용, 몰랐던 내용을 팀원들과 공유하고 많은 사람들의 생각들을 공유받음으로서 도움을 받을 수 있었다.

도움을 줄 수 있는 부분, 얻어갈 수 있는 부분을 충분히 이야기함으로서 좋은 영향 받아가는 것 같았고 피어 세션의 매력을 충분히 느낄 수 있는 시간이었던 것 같다.

## 8. 해야할 일
- SGD 심화 학습
- Epoch와 Iteration에 대한 정리
- 불편추정량이란?
- 특이값 분해란?
- 중심극한정리란?
- Universal Approximation Theorem
- 분류문제에서 사용되는 Cross Entropy
